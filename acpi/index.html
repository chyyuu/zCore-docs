<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A library for parsing ACPI tables. This crate can be used by bootloaders and kernels for architectures that support ACPI. The crate is far from feature-complete, but can still be used for finding and parsing the static tables, which is enough to set up hardware such as the APIC and HPET on x86_64."><meta name="keywords" content="rust, rustlang, rust-lang, acpi"><title>acpi - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../ayu.css" disabled ><script id="default-settings"></script><script src="../storage.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="icon" type="image/svg+xml" href="../favicon.svg">
<link rel="alternate icon" type="image/png" href="../favicon-16x16.png">
<link rel="alternate icon" type="image/png" href="../favicon-32x32.png"><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc mod"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a href='../acpi/index.html'><div class='logo-container rust-logo'><img src='../rust-logo.png' alt='logo'></div></a><p class="location">Crate acpi</p><div class="block version"><p>Version 1.1.0</p></div><div class="sidebar-elems"><a id="all-types" href="all.html"><p>See all acpi's items</p></a><div class="block items"><ul><li><a href="#reexports">Re-exports</a></li><li><a href="#modules">Modules</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#functions">Functions</a></li></ul></div><p class="location"></p><div id="sidebar-vars" data-name="acpi" data-ty="mod" data-relpath="../"></div></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu"><img src="../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices" role="menu"></div></div><script src="../theme.js"></script><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" class="help-button">?</button>
                <a id="settings-menu" href="../settings.html"><img src="../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Crate <a class="mod" href="">acpi</a></span><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../src/acpi/lib.rs.html#1-248" title="goto source code">[src]</a></span></h1><div class="docblock"><p>A library for parsing ACPI tables. This crate can be used by bootloaders and kernels for
architectures that support ACPI. The crate is far from feature-complete, but can still be used
for finding and parsing the static tables, which is enough to set up hardware such as the APIC
and HPET on x86_64.</p>
<p>The crate is designed for use in conjunction with the <code>aml</code> crate, which is the (much
less complete) AML parser used to parse the DSDT and SSDTs. These crates are separate because
some kernels may want to detect the static tables, but delay AML parsing to a later stage.</p>
<h3 id="usage" class="section-header"><a href="#usage">Usage</a></h3>
<p>To use the library, you will need to provide an implementation of the <code>AcpiHandler</code> trait,
which allows the library to make requests such as mapping a particular region of physical
memory into the virtual address space.</p>
<p>You should then call one of the entry points, based on how much information you have:</p>
<ul>
<li>Call <code>parse_rsdp</code> if you have the physical address of the RSDP</li>
<li>Call <code>parse_rsdt</code> if you have the physical address of the RSDT / XSDT</li>
<li>Call <code>search_for_rsdp_bios</code> if you don’t have the address of either structure, but <strong>you know
you’re running on BIOS, not UEFI</strong></li>
</ul>
<p>All of these methods return an instance of <code>Acpi</code>. This struct contains all the information
gathered from the static tables, and can be queried to set up hardware etc.</p>
</div><h2 id="reexports" class="section-header"><a href="#reexports">Re-exports</a></h2>
<table><tr><td><code>pub use crate::handler::<a class="trait" href="../acpi/handler/trait.AcpiHandler.html" title="trait acpi::handler::AcpiHandler">AcpiHandler</a>;</code></td></tr><tr><td><code>pub use crate::handler::<a class="struct" href="../acpi/handler/struct.PhysicalMapping.html" title="struct acpi::handler::PhysicalMapping">PhysicalMapping</a>;</code></td></tr><tr><td><code>pub use crate::interrupt::<a class="enum" href="../acpi/interrupt/enum.InterruptModel.html" title="enum acpi::interrupt::InterruptModel">InterruptModel</a>;</code></td></tr></table><h2 id="modules" class="section-header"><a href="#modules">Modules</a></h2>
<table><tr class="module-item"><td><a class="mod" href="handler/index.html" title="acpi::handler mod">handler</a></td><td class="docblock-short"></td></tr><tr class="module-item"><td><a class="mod" href="interrupt/index.html" title="acpi::interrupt mod">interrupt</a></td><td class="docblock-short"></td></tr></table><h2 id="structs" class="section-header"><a href="#structs">Structs</a></h2>
<table><tr class="module-item"><td><a class="struct" href="struct.Acpi.html" title="acpi::Acpi struct">Acpi</a></td><td class="docblock-short"></td></tr><tr class="module-item"><td><a class="struct" href="struct.AmlTable.html" title="acpi::AmlTable struct">AmlTable</a></td><td class="docblock-short"></td></tr><tr class="module-item"><td><a class="struct" href="struct.HpetInfo.html" title="acpi::HpetInfo struct">HpetInfo</a></td><td class="docblock-short"><p>Information about the High Precision Event Timer</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.PciConfigRegions.html" title="acpi::PciConfigRegions struct">PciConfigRegions</a></td><td class="docblock-short"><p>Describes a set of regions of physical memory used to access the PCIe configuration space. A
region is created for each entry in the MCFG. Given the segment group, bus, device number, and
function of a PCIe device, the <code>physical_address</code> method on this will give you the physical
address of the start of that device function’s configuration space (each function has 4096
bytes of configuration space in PCIe).</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.Processor.html" title="acpi::Processor struct">Processor</a></td><td class="docblock-short"></td></tr></table><h2 id="enums" class="section-header"><a href="#enums">Enums</a></h2>
<table><tr class="module-item"><td><a class="enum" href="enum.AcpiError.html" title="acpi::AcpiError enum">AcpiError</a></td><td class="docblock-short"></td></tr><tr class="module-item"><td><a class="enum" href="enum.MadtError.html" title="acpi::MadtError enum">MadtError</a></td><td class="docblock-short"></td></tr><tr class="module-item"><td><a class="enum" href="enum.PowerProfile.html" title="acpi::PowerProfile enum">PowerProfile</a></td><td class="docblock-short"></td></tr><tr class="module-item"><td><a class="enum" href="enum.ProcessorState.html" title="acpi::ProcessorState enum">ProcessorState</a></td><td class="docblock-short"></td></tr></table><h2 id="functions" class="section-header"><a href="#functions">Functions</a></h2>
<table><tr class="module-item"><td><a class="fn" href="fn.parse_rsdp.html" title="acpi::parse_rsdp fn">parse_rsdp</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><p>This is the entry point of <code>acpi</code> if you have the <strong>physical</strong> address of the RSDP. It maps
the RSDP, works out what version of ACPI the hardware supports, and passes the physical
address of the RSDT/XSDT to <code>parse_rsdt</code>.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.parse_rsdt.html" title="acpi::parse_rsdt fn">parse_rsdt</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><p>This is the entry point of <code>acpi</code> if you already have the <strong>physical</strong> address of the
RSDT/XSDT; it parses all the SDTs in the RSDT/XSDT, calling the relevant handlers in the
implementation’s <code>AcpiHandler</code>.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.search_for_rsdp_bios.html" title="acpi::search_for_rsdp_bios fn">search_for_rsdp_bios</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><p>This is the entry point of <code>acpi</code> if you have no information except that the machine is running
BIOS and not UEFI. It maps the RSDP, works out what version of ACPI the hardware supports, and
passes the physical address of the RSDT/XSDT to <code>parse_rsdt</code>.</p>
</td></tr></table></section><section id="search" class="content hidden"></section><section class="footer"></section><div id="rustdoc-vars" data-root-path="../" data-current-crate="acpi"></div>
    <script src="../main.js"></script><script defer src="../search-index.js"></script></body></html>